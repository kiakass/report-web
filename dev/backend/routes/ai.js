const express = require('express');
const router = express.Router();
const database = require('../config/database');

// AI Î∂ÑÏÑù ÏÑúÎπÑÏä§ ÌÅ¥ÎûòÏä§
class AIAnalysisService {
  constructor() {
    this.processingQueue = new Map();
  }

  // AI Î∂ÑÏÑù ÏãúÏûë
  async startAnalysis(reportId) {
    try {
      // Î¶¨Ìè¨Ìä∏ Ï†ïÎ≥¥ Ï°∞Ìöå
      const report = await database.get(`
        SELECT * FROM reports WHERE id = ?
      `, [reportId]);

      if (!report) {
        throw new Error('Report not found');
      }

      // ÏóÖÎ°úÎìúÎêú ÌååÏùº Ï°∞Ìöå
      const files = await database.all(`
        SELECT * FROM uploaded_files WHERE report_id = ?
      `, [reportId]);

      if (files.length === 0) {
        throw new Error('No files uploaded for analysis');
      }

      // ÏÉÅÌÉúÎ•º processingÏúºÎ°ú Î≥ÄÍ≤Ω
      await database.run(`
        UPDATE reports SET status = 'processing', updated_at = CURRENT_TIMESTAMP
        WHERE id = ?
      `, [reportId]);

      // ÎπÑÎèôÍ∏∞Î°ú AI Î∂ÑÏÑù Ïã§Ìñâ
      this.processAnalysis(reportId, report, files);

      return {
        success: true,
        report_id: reportId,
        message: 'AI analysis started',
        files_count: files.length
      };

    } catch (error) {
      console.error('AI analysis start error:', error);
      throw error;
    }
  }

  // AI Î∂ÑÏÑù Ï≤òÎ¶¨ (ÎπÑÎèôÍ∏∞)
  async processAnalysis(reportId, report, files) {
    try {
      console.log(`ü§ñ Starting AI analysis for report ${reportId}`);

      // Í∞Å ÌååÏùºÎ≥Ñ Î∂ÑÏÑù ÏàòÌñâ
      for (const file of files) {
        await this.analyzeFile(reportId, file, report);
      }

      // Ï¢ÖÌï© Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
      const finalReport = await this.generateFinalReport(reportId, report, files);

      // ÏÉÅÌÉúÎ•º completedÎ°ú Î≥ÄÍ≤Ω
      await database.run(`
        UPDATE reports 
        SET status = 'completed', 
            ai_report_content = ?, 
            ai_report_summary = ?,
            completed_at = CURRENT_TIMESTAMP,
            updated_at = CURRENT_TIMESTAMP
        WHERE id = ?
      `, [finalReport.content, finalReport.summary, reportId]);

      console.log(`‚úÖ AI analysis completed for report ${reportId}`);

    } catch (error) {
      console.error(`‚ùå AI analysis failed for report ${reportId}:`, error);
      
      // ÏÉÅÌÉúÎ•º failedÎ°ú Î≥ÄÍ≤Ω
      await database.run(`
        UPDATE reports 
        SET status = 'failed', 
            updated_at = CURRENT_TIMESTAMP
        WHERE id = ?
      `, [reportId]);
    }
  }

  // Í∞úÎ≥Ñ ÌååÏùº Î∂ÑÏÑù
  async analyzeFile(reportId, file, report) {
    try {
      console.log(`üìä Analyzing file: ${file.original_name} (${file.analysis_type})`);

      // ÌååÏùº ÌÉÄÏûÖÎ≥Ñ Î∂ÑÏÑù Î°úÏßÅ
      let analysisResult = {};

      switch (file.analysis_type) {
        case 'demographics':
          analysisResult = await this.analyzeDemographics(file, report);
          break;
        case 'timeSeries':
          analysisResult = await this.analyzeTimeSeries(file, report);
          break;
        case 'visitedSites':
          analysisResult = await this.analyzeVisitedSites(file, report);
          break;
        case 'crossVisit':
          analysisResult = await this.analyzeCrossVisit(file, report);
          break;
        default:
          throw new Error(`Unknown analysis type: ${file.analysis_type}`);
      }

      // Î∂ÑÏÑù Í≤∞Í≥º Ï†ÄÏû•
      await database.run(`
        INSERT INTO ai_analysis_results (report_id, analysis_type, result_data)
        VALUES (?, ?, ?)
      `, [reportId, file.analysis_type, JSON.stringify(analysisResult)]);

      console.log(`‚úÖ Analysis completed for ${file.analysis_type}`);

    } catch (error) {
      console.error(`‚ùå File analysis failed: ${file.original_name}`, error);
      throw error;
    }
  }

  // Ïù∏Íµ¨ÌÜµÍ≥ÑÌïôÏ†Å Î∂ÑÏÑù
  async analyzeDemographics(file, report) {
    // Ïã§Ï†ú AI Î∂ÑÏÑù Î°úÏßÅ Íµ¨ÌòÑ
    return {
      type: 'demographics',
      summary: 'Ïù∏Íµ¨ÌÜµÍ≥ÑÌïôÏ†Å Î∂ÑÏÑù Í≤∞Í≥º',
      key_findings: [
        'Ï£ºÏöî Ïó∞Î†πÎåÄ: 30-40ÎåÄ',
        'ÏÑ±Î≥Ñ Î∂ÑÌè¨: ÎÇ®ÏÑ± 60%, Ïó¨ÏÑ± 40%',
        'ÏßÄÏó≠Î≥Ñ Î∂ÑÌè¨: ÏÑúÏö∏ 45%, Í≤ΩÍ∏∞ 30%, Í∏∞ÌÉÄ 25%'
      ],
      charts: {
        age_distribution: { /* Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ */ },
        gender_distribution: { /* Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ */ },
        location_distribution: { /* Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ */ }
      },
      recommendations: [
        '30-40ÎåÄ ÌÉÄÍ≤ü ÎßàÏºÄÌåÖ Í∞ïÌôî',
        'ÎÇ®ÏÑ± Í≥†Í∞ù ÎåÄÏÉÅ ÏÑúÎπÑÏä§ Í∞úÏÑ†',
        'ÏÑúÏö∏ ÏßÄÏó≠ ÏßëÏ§ë ÎßàÏºÄÌåÖ'
      ]
    };
  }

  // ÏãúÍ≥ÑÏó¥ Î∂ÑÏÑù
  async analyzeTimeSeries(file, report) {
    return {
      type: 'timeSeries',
      summary: 'ÏãúÍ≥ÑÏó¥ Î∂ÑÏÑù Í≤∞Í≥º',
      key_findings: [
        'ÏõîÎ≥Ñ Ìä∏Î†åÎìú: 3-4Ïõî ÏÑ±Ïû•ÏÑ∏',
        'Ï£ºÍ∞Ñ Ìå®ÌÑ¥: ÏõîÏöîÏùº-ÏàòÏöîÏùº ÌôúÏÑ±ÎèÑ ÎÜíÏùå',
        'ÏãúÍ∞ÑÎåÄÎ≥Ñ: Ïò§ÌõÑ 2-6Ïãú ÌîºÌÅ¨'
      ],
      charts: {
        monthly_trend: { /* Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ */ },
        weekly_pattern: { /* Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ */ },
        hourly_distribution: { /* Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ */ }
      },
      recommendations: [
        '3-4Ïõî ÎßàÏºÄÌåÖ Ï∫†ÌéòÏù∏ ÏßëÏ§ë',
        'Ïõî-Ïàò Ïò§Ï†Ñ ÏãúÍ∞ÑÎåÄ ÏÑúÎπÑÏä§ Í∞úÏÑ†',
        'Ïò§ÌõÑ 2-6Ïãú Í≥†Í∞ù ÏÑúÎπÑÏä§ Í∞ïÌôî'
      ]
    };
  }

  // Ï£ºÏöî Î∞©Î¨∏ ÏÇ¨Ïù¥Ìä∏ Î∂ÑÏÑù
  async analyzeVisitedSites(file, report) {
    return {
      type: 'visitedSites',
      summary: 'Ï£ºÏöî Î∞©Î¨∏ ÏÇ¨Ïù¥Ìä∏ Î∂ÑÏÑù Í≤∞Í≥º',
      key_findings: [
        'ÏÉÅÏúÑ Î∞©Î¨∏ ÏÇ¨Ïù¥Ìä∏: ÎÑ§Ïù¥Î≤Ñ, Íµ¨Í∏Ä, Ïπ¥Ïπ¥Ïò§',
        'ÏóÖÏ¢ÖÎ≥Ñ ÏÑ†Ìò∏ÎèÑ: IT/Í∏∞Ïà†, Í∏àÏúµ, ÏáºÌïë',
        'Í≤ΩÏüÅÏÇ¨ ÏÇ¨Ïù¥Ìä∏ Î∞©Î¨∏Î•†: 15%'
      ],
      charts: {
        top_sites: { /* Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ */ },
        industry_preference: { /* Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ */ },
        competitor_visits: { /* Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ */ }
      },
      recommendations: [
        'ÎÑ§Ïù¥Î≤Ñ/Íµ¨Í∏Ä Í¥ëÍ≥† ÏßëÏ§ë Ìà¨Ïûê',
        'IT/Í∏∞Ïà† ÏóÖÏ¢Ö ÌÉÄÍ≤ü ÎßàÏºÄÌåÖ',
        'Í≤ΩÏüÅÏÇ¨ ÎåÄÎπÑ Ï∞®Î≥ÑÌôî Ï†ÑÎûµ ÏàòÎ¶Ω'
      ]
    };
  }

  // ÍµêÏ∞® Î∞©Î¨∏Ïú® Î∂ÑÏÑù
  async analyzeCrossVisit(file, report) {
    return {
      type: 'crossVisit',
      summary: 'ÍµêÏ∞® Î∞©Î¨∏Ïú® Î∂ÑÏÑù Í≤∞Í≥º',
      key_findings: [
        'Í≤ΩÏüÅÏÇ¨ÏôÄÏùò ÍµêÏ∞® Î∞©Î¨∏Î•†: 25%',
        'ÏÉÅÍ¥ÄÍ¥ÄÍ≥Ñ ÎÜíÏùÄ ÏÇ¨Ïù¥Ìä∏: AÏÇ¨(40%), BÏÇ¨(30%)',
        'ÎèÖÏ†ê Í≥†Í∞ù ÎπÑÏú®: 75%'
      ],
      charts: {
        cross_visit_matrix: { /* Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ */ },
        customer_loyalty: { /* Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ */ },
        competitive_analysis: { /* Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ */ }
      },
      recommendations: [
        'AÏÇ¨, BÏÇ¨ Í≥†Í∞ù ÌÉÄÍ≤ü ÎßàÏºÄÌåÖ',
        'ÎèÖÏ†ê Í≥†Í∞ù Ï∂©ÏÑ±ÎèÑ ÌîÑÎ°úÍ∑∏Îû® Í∞ïÌôî',
        'Í≤ΩÏüÅÏÇ¨ ÎåÄÎπÑ ÏÑúÎπÑÏä§ Ï∞®Î≥ÑÌôî'
      ]
    };
  }

  // Ï¢ÖÌï© Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
  async generateFinalReport(reportId, report, files) {
    // Î™®Îì† Î∂ÑÏÑù Í≤∞Í≥º Ï°∞Ìöå
    const analysisResults = await database.all(`
      SELECT * FROM ai_analysis_results WHERE report_id = ?
    `, [reportId]);

    // Ï¢ÖÌï© Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± Î°úÏßÅ
    const summary = this.generateSummary(analysisResults, report);
    const content = this.generateDetailedReport(analysisResults, report, files);

    return {
      summary,
      content
    };
  }

  // ÏöîÏïΩ Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
  generateSummary(analysisResults, report) {
    return {
      report_name: report.report_name,
      analysis_period: `${report.start_date} ~ ${report.end_date}`,
      total_files: analysisResults.length,
      key_insights: [
        'Ï£ºÏöî ÌÉÄÍ≤ü: 30-40ÎåÄ ÎÇ®ÏÑ±',
        'ÏµúÏ†Å ÎßàÏºÄÌåÖ ÏãúÍ∏∞: 3-4Ïõî',
        'ÌïµÏã¨ Í≤ΩÏüÅÏÇ¨: AÏÇ¨, BÏÇ¨',
        'Í≥†Í∞ù Ï∂©ÏÑ±ÎèÑ: 75%'
      ],
      recommendations: [
        '30-40ÎåÄ ÎÇ®ÏÑ± ÌÉÄÍ≤ü ÎßàÏºÄÌåÖ Í∞ïÌôî',
        '3-4Ïõî ÏßëÏ§ë Ï∫†ÌéòÏù∏ Ïã§Ìñâ',
        'AÏÇ¨, BÏÇ¨ Í≥†Í∞ù ÌÉÄÍ≤üÌåÖ',
        'Ï∂©ÏÑ± Í≥†Í∞ù ÌîÑÎ°úÍ∑∏Îû® Í∞úÎ∞ú'
      ]
    };
  }

  // ÏÉÅÏÑ∏ Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
  generateDetailedReport(analysisResults, report, files) {
    return {
      report_info: {
        name: report.report_name,
        period: `${report.start_date} ~ ${report.end_date}`,
        age_range: `${report.min_age}~${report.max_age}ÏÑ∏`,
        created_at: report.created_at
      },
      analysis_files: files.map(f => ({
        name: f.original_name,
        type: f.analysis_type,
        size: f.file_size
      })),
      analysis_results: analysisResults.map(result => ({
        type: result.analysis_type,
        data: JSON.parse(result.result_data)
      })),
      executive_summary: 'Ïù¥Î≤à Î∂ÑÏÑùÏùÑ ÌÜµÌï¥ Í≥†Í∞ùÏùò ÌñâÎèô Ìå®ÌÑ¥Í≥º ÏÑ†Ìò∏ÎèÑÎ•º ÌååÏïÖÌñàÏäµÎãàÎã§...',
      detailed_findings: 'Í∞Å Î∂ÑÏÑù Ìï≠Î™©Î≥Ñ ÏÉÅÏÑ∏ Í≤∞Í≥º...',
      strategic_recommendations: 'Î∂ÑÏÑù Í≤∞Í≥ºÎ•º Î∞îÌÉïÏúºÎ°ú Ìïú Ï†ÑÎûµÏ†Å Ï†úÏïà...'
    };
  }
}

// AI Î∂ÑÏÑù ÏÑúÎπÑÏä§ Ïù∏Ïä§ÌÑ¥Ïä§
const aiService = new AIAnalysisService();

// 1. AI Î∂ÑÏÑù ÏãúÏûë
router.post('/:reportId/analyze', async (req, res) => {
  try {
    const { reportId } = req.params;

    const result = await aiService.startAnalysis(reportId);

    res.json(result);

  } catch (error) {
    console.error('AI analysis start error:', error);
    res.status(500).json({
      error: 'Failed to start AI analysis',
      message: error.message
    });
  }
});

// 2. Î∂ÑÏÑù ÏÉÅÌÉú Ï°∞Ìöå
router.get('/:reportId/status', async (req, res) => {
  try {
    const { reportId } = req.params;

    const report = await database.get(`
      SELECT id, status, created_at, completed_at, ai_report_summary
      FROM reports WHERE id = ?
    `, [reportId]);

    if (!report) {
      return res.status(404).json({
        error: 'Report not found'
      });
    }

    // Î∂ÑÏÑù Í≤∞Í≥º Ï°∞Ìöå
    const analysisResults = await database.all(`
      SELECT analysis_type, created_at 
      FROM ai_analysis_results 
      WHERE report_id = ?
      ORDER BY created_at
    `, [reportId]);

    res.json({
      report_id: reportId,
      status: report.status,
      created_at: report.created_at,
      completed_at: report.completed_at,
      analysis_results: analysisResults,
      summary: report.ai_report_summary ? JSON.parse(report.ai_report_summary) : null
    });

  } catch (error) {
    console.error('Analysis status error:', error);
    res.status(500).json({
      error: 'Failed to fetch analysis status',
      message: error.message
    });
  }
});

// 3. Î∂ÑÏÑù Í≤∞Í≥º Ï°∞Ìöå
router.get('/:reportId/results', async (req, res) => {
  try {
    const { reportId } = req.params;

    const report = await database.get(`
      SELECT * FROM reports WHERE id = ?
    `, [reportId]);

    if (!report) {
      return res.status(404).json({
        error: 'Report not found'
      });
    }

    if (report.status !== 'completed') {
      return res.status(400).json({
        error: 'Analysis not completed',
        status: report.status
      });
    }

    const analysisResults = await database.all(`
      SELECT * FROM ai_analysis_results 
      WHERE report_id = ?
      ORDER BY created_at
    `, [reportId]);

    res.json({
      report: {
        id: report.id,
        name: report.report_name,
        status: report.status,
        created_at: report.created_at,
        completed_at: report.completed_at,
        content: report.ai_report_content ? JSON.parse(report.ai_report_content) : null,
        summary: report.ai_report_summary ? JSON.parse(report.ai_report_summary) : null
      },
      analysis_results: analysisResults.map(result => ({
        type: result.analysis_type,
        data: JSON.parse(result.result_data),
        created_at: result.created_at
      }))
    });

  } catch (error) {
    console.error('Analysis results error:', error);
    res.status(500).json({
      error: 'Failed to fetch analysis results',
      message: error.message
    });
  }
});

module.exports = router;
